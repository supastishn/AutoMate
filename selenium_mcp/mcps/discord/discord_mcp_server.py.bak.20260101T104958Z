#!/usr/bin/env python3
"""
Discord MCP Server - Provides AI access to Discord via Selenium WebDriver.

This MCP server enables AI assistants to:
- Login to Discord with credentials and 2FA support
- Navigate channels and servers
- Read and send messages
- Check notifications
- Manage DMs
- Automate Discord interactions

Configuration follows test.py pattern:
- Headless mode by default
- Explicit geckodriver path
- Firefox browser
"""

import asyncio
import base64
import json
import os
import time
from typing import Any, Optional, List, Dict
from datetime import datetime

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.remote.webelement import WebElement
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
    WebDriverException,
    StaleElementReferenceException,
    ElementNotInteractableException,
)

from mcp.server.fastmcp import FastMCP

# Global browser instance
_browser: Optional[webdriver.Firefox] = None

# Discord state
_discord_state = {
    "logged_in": False,
    "current_server": None,
    "current_channel": None,
    "username": None,
}

# Default configuration
DEFAULT_DRIVER_PATH = "/usr/bin/geckodriver"
DEFAULT_HEADLESS = True
DEFAULT_WINDOW_WIDTH = 1920
DEFAULT_WINDOW_HEIGHT = 1080

# Discord URLs
DISCORD_LOGIN_URL = "https://discord.com/login"
DISCORD_APP_URL = "https://discord.com/app"
DISCORD_CHANNELS_URL = "https://discord.com/channels/@me"

# Initialize MCP server
mcp = FastMCP("Discord Automation")


def get_by_strategy(by: str) -> By:
    """Convert string strategy to Selenium By enum."""
    strategies = {
        "css": By.CSS_SELECTOR,
        "xpath": By.XPATH,
        "id": By.ID,
        "class": By.CLASS_NAME,
        "tag": By.TAG_NAME,
        "name": By.NAME,
        "link_text": By.LINK_TEXT,
        "partial_link_text": By.PARTIAL_LINK_TEXT,
    }
    return strategies.get(by.lower(), By.CSS_SELECTOR)


def element_to_dict(element: WebElement) -> dict:
    """Convert WebElement to dictionary representation."""
    try:
        return {
            "tag_name": element.tag_name,
            "text": element.text,
            "is_displayed": element.is_displayed(),
            "is_enabled": element.is_enabled(),
            "location": element.location,
            "size": element.size,
            "attributes": {
                "id": element.get_attribute("id"),
                "class": element.get_attribute("class"),
                "name": element.get_attribute("name"),
                "href": element.get_attribute("href"),
                "aria-label": element.get_attribute("aria-label"),
                "data-list-item-id": element.get_attribute("data-list-item-id"),
            }
        }
    except StaleElementReferenceException:
        return {"error": "Element is stale (page may have changed)"}


def wait_for_discord_load(timeout: int = 30) -> bool:
    """Wait for Discord to fully load after navigation."""
    global _browser
    if _browser is None:
        return False

    try:
        # Wait for the app to load (message input or server list appears)
        WebDriverWait(_browser, timeout).until(
            lambda d: d.find_elements(By.CSS_SELECTOR, 'div[role="textbox"]') or
                     d.find_elements(By.CSS_SELECTOR, '[aria-label="Servers"]') or
                     d.find_elements(By.CSS_SELECTOR, '[class*="guilds"]')
        )
        time.sleep(2)  # Extra time for React to stabilize
        return True
    except TimeoutException:
        return False


def safe_click(element: WebElement) -> bool:
    """Safely click an element with retry logic."""
    global _browser
    try:
        element.click()
        return True
    except ElementNotInteractableException:
        try:
            _browser.execute_script("arguments[0].click();", element)
            return True
        except:
            return False
    except:
        return False


# ============================================================================
# Browser Session Management Tools
# ============================================================================

@mcp.tool()
def start_discord_browser(
    headless: bool = True,
    driver_path: str = "/usr/bin/geckodriver",
    window_width: int = 1920,
    window_height: int = 1080,
) -> dict:
    """
    Start a Firefox browser session for Discord automation.

    Args:
        headless: Run browser in headless mode (no GUI). Default True.
        driver_path: Path to geckodriver executable. Default /usr/bin/geckodriver.
        window_width: Browser window width in pixels. Default 1920.
        window_height: Browser window height in pixels. Default 1080.

    Returns:
        Status dict with success boolean and message.
    """
    global _browser, _discord_state

    if _browser is not None:
        return {
            "success": False,
            "message": "Browser already running. Call stop_discord_browser first."
        }

    try:
        # Configure Firefox options (following test.py pattern)
        firefox_options = Options()

        if headless:
            firefox_options.add_argument("--headless")

        firefox_options.add_argument(f"--width={window_width}")
        firefox_options.add_argument(f"--height={window_height}")
        firefox_options.accept_insecure_certs = True

        # Add preferences for Discord compatibility
        firefox_options.set_preference("dom.webdriver.enabled", False)
        firefox_options.set_preference("useAutomationExtension", False)

        # Create service with explicit driver path (from test.py)
        service = Service(executable_path=driver_path)

        # Initialize browser
        _browser = webdriver.Firefox(options=firefox_options, service=service)

        # Reset Discord state
        _discord_state = {
            "logged_in": False,
            "current_server": None,
            "current_channel": None,
            "username": None,
        }

        return {
            "success": True,
            "message": f"Discord browser started. Headless: {headless}, Size: {window_width}x{window_height}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to start browser: {str(e)}"
        }


@mcp.tool()
def stop_discord_browser() -> dict:
    """
    Stop the Discord browser session and clean up resources.

    Returns:
        Status dict with success boolean and message.
    """
    global _browser, _discord_state

    if _browser is None:
        return {
            "success": False,
            "message": "No browser session running."
        }

    try:
        _browser.quit()
        _browser = None
        _discord_state = {
            "logged_in": False,
            "current_server": None,
            "current_channel": None,
            "username": None,
        }
        return {
            "success": True,
            "message": "Discord browser stopped successfully."
        }
    except Exception as e:
        _browser = None
        return {
            "success": False,
            "message": f"Error stopping browser: {str(e)}"
        }


@mcp.tool()
def get_discord_status() -> dict:
    """
    Get current Discord session status.

    Returns:
        Dict with Discord session status information.
    """
    global _browser, _discord_state

    if _browser is None:
        return {
            "browser_running": False,
            "logged_in": False,
            "current_url": None,
            "state": _discord_state
        }

    try:
        return {
            "browser_running": True,
            "logged_in": _discord_state["logged_in"],
            "current_url": _browser.current_url,
            "page_title": _browser.title,
            "state": _discord_state
        }
    except Exception as e:
        return {
            "browser_running": True,
            "error": str(e),
            "state": _discord_state
        }


# ============================================================================
# Authentication Tools
# ============================================================================

@mcp.tool()
def discord_login(
    email: str,
    password: str,
    timeout: int = 30,
) -> dict:
    """
    Login to Discord with email and password.

    If 2FA is required, the function will return a status indicating 2FA is needed.
    Use discord_submit_2fa to complete the login.

    Args:
        email: Discord account email or phone number.
        password: Discord account password.
        timeout: Maximum time to wait for login in seconds. Default 30.

    Returns:
        Status dict with login result. If 2FA is required, success will be False
        and requires_2fa will be True.
    """
    global _browser, _discord_state

    if _browser is None:
        return {
            "success": False,
            "message": "Browser not running. Call start_discord_browser first."
        }

    try:
        # Navigate to Discord login page
        _browser.get(DISCORD_LOGIN_URL)
        time.sleep(3)  # Wait for page to load

        # Wait for email input
        email_input = WebDriverWait(_browser, timeout).until(
            EC.presence_of_element_located((By.NAME, "email"))
        )

        # Clear and enter email
        email_input.clear()
        email_input.send_keys(email)

        # Find and enter password
        password_input = _browser.find_element(By.NAME, "password")
        password_input.clear()
        password_input.send_keys(password)

        # Click login button
        login_button = _browser.find_element(By.CSS_SELECTOR, 'button[type="submit"]')
        login_button.click()

        # Wait for result - either 2FA prompt, captcha, error, or success
        time.sleep(5)

        # Check for various outcomes
        current_url = _browser.current_url
        page_source = _browser.page_source.lower()

        # Check for captcha
        if "captcha" in page_source or "hcaptcha" in page_source:
            return {
                "success": False,
                "requires_captcha": True,
                "message": "Captcha required. Please solve manually or use a different approach."
            }

        # Check for 2FA prompt
        if "two-factor" in page_source or "2fa" in page_source or "authentication code" in page_source:
            return {
                "success": False,
                "requires_2fa": True,
                "message": "2FA required. Use discord_submit_2fa to complete login."
            }

        # Check for invalid credentials
        if "invalid" in page_source and ("password" in page_source or "email" in page_source):
            return {
                "success": False,
                "message": "Invalid email or password."
            }

        # Check if we're logged in (redirected to app)
        if "/channels" in current_url or "/app" in current_url:
            _discord_state["logged_in"] = True
            _discord_state["username"] = email

            # Wait for Discord to fully load
            wait_for_discord_load(timeout)

            return {
                "success": True,
                "message": "Successfully logged in to Discord.",
                "current_url": current_url
            }

        # Unknown state
        return {
            "success": False,
            "message": "Login state unclear. Check current page.",
            "current_url": current_url
        }

    except TimeoutException:
        return {
            "success": False,
            "message": "Timeout waiting for login elements."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Login failed: {str(e)}"
        }


@mcp.tool()
def discord_submit_2fa(
    code: str,
    timeout: int = 30,
) -> dict:
    """
    Submit 2FA code to complete Discord login.

    Args:
        code: The 6-digit 2FA code from authenticator app.
        timeout: Maximum time to wait in seconds. Default 30.

    Returns:
        Status dict with 2FA submission result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {
            "success": False,
            "message": "Browser not running."
        }

    try:
        # Find 2FA input field - try multiple selectors
        two_fa_input = None
        selectors = [
            'input[placeholder*="code"]',
            'input[aria-label*="code"]',
            'input[autocomplete="one-time-code"]',
            'input[type="text"]',
        ]

        for selector in selectors:
            try:
                elements = _browser.find_elements(By.CSS_SELECTOR, selector)
                for el in elements:
                    if el.is_displayed():
                        two_fa_input = el
                        break
                if two_fa_input:
                    break
            except:
                continue

        if not two_fa_input:
            return {
                "success": False,
                "message": "Could not find 2FA input field."
            }

        # Enter 2FA code
        two_fa_input.clear()
        two_fa_input.send_keys(code)

        # Try to submit - look for submit button or press Enter
        try:
            submit_btn = _browser.find_element(By.CSS_SELECTOR, 'button[type="submit"]')
            submit_btn.click()
        except:
            two_fa_input.send_keys(Keys.ENTER)

        # Wait for result
        time.sleep(5)

        current_url = _browser.current_url

        # Check if we're logged in
        if "/channels" in current_url or "/app" in current_url:
            _discord_state["logged_in"] = True
            wait_for_discord_load(timeout)

            return {
                "success": True,
                "message": "2FA verified. Successfully logged in.",
                "current_url": current_url
            }

        # Check for invalid code
        page_source = _browser.page_source.lower()
        if "invalid" in page_source:
            return {
                "success": False,
                "message": "Invalid 2FA code. Please try again."
            }

        return {
            "success": False,
            "message": "2FA submission result unclear.",
            "current_url": current_url
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"2FA submission failed: {str(e)}"
        }


@mcp.tool()
def discord_login_with_token(token: str) -> dict:
    """
    Login to Discord using an authentication token.

    WARNING: This method uses Discord tokens which is against Discord TOS.
    Use responsibly and only with your own accounts.

    Args:
        token: Discord authentication token.

    Returns:
        Status dict with login result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {
            "success": False,
            "message": "Browser not running. Call start_discord_browser first."
        }

    try:
        # Navigate to Discord
        _browser.get(DISCORD_LOGIN_URL)
        time.sleep(2)

        # Inject token into localStorage
        script = f'''
            function login(token) {{
                setInterval(() => {{
                    document.body.appendChild(document.createElement('iframe')).contentWindow.localStorage.token = `"${{token}}"`;
                }}, 50);
                setTimeout(() => {{
                    location.reload();
                }}, 2500);
            }}
            login("{token}");
        '''
        _browser.execute_script(script)

        # Wait for reload and login
        time.sleep(5)

        current_url = _browser.current_url

        if "/channels" in current_url or "/app" in current_url:
            _discord_state["logged_in"] = True
            wait_for_discord_load()

            return {
                "success": True,
                "message": "Token login successful.",
                "current_url": current_url
            }

        return {
            "success": False,
            "message": "Token login may have failed. Check current page.",
            "current_url": current_url
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Token login failed: {str(e)}"
        }


@mcp.tool()
def discord_logout() -> dict:
    """
    Logout from Discord.

    Returns:
        Status dict with logout result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {
            "success": False,
            "message": "Browser not running."
        }

    try:
        # Click user settings button
        settings_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="User Settings"]')
        settings_btn.click()
        time.sleep(1)

        # Find and click logout
        logout_btn = _browser.find_element(By.XPATH, "//*[contains(text(), 'Log Out')]")
        logout_btn.click()
        time.sleep(1)

        # Confirm logout if dialog appears
        try:
            confirm_btn = _browser.find_element(By.XPATH, "//button[contains(text(), 'Log Out')]")
            confirm_btn.click()
        except:
            pass

        time.sleep(3)

        _discord_state["logged_in"] = False
        _discord_state["username"] = None

        return {
            "success": True,
            "message": "Logged out successfully."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Logout failed: {str(e)}"
        }


# ============================================================================
# Server & Channel Navigation Tools
# ============================================================================

@mcp.tool()
def get_servers() -> dict:
    """
    Get list of all servers the user is a member of.

    Returns:
        Dict with list of servers.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        servers = []

        # Find server list
        server_elements = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="guildsnav___"]')

        for el in server_elements:
            try:
                server_id = el.get_attribute("data-list-item-id")
                aria_label = el.get_attribute("aria-label")

                # Extract server name from aria-label
                name = aria_label.split(",")[0] if aria_label else "Unknown"

                servers.append({
                    "id": server_id,
                    "name": name,
                    "has_unread": "unread" in aria_label.lower() if aria_label else False
                })
            except:
                continue

        return {
            "success": True,
            "servers": servers,
            "count": len(servers)
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get servers: {str(e)}"
        }


@mcp.tool()
def select_server(server_name: str) -> dict:
    """
    Select a server by name.

    Args:
        server_name: Name of the server to select (partial match supported).

    Returns:
        Status dict with selection result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find server by name in aria-label
        server_elements = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="guildsnav___"]')

        target_server = None
        for el in server_elements:
            aria_label = el.get_attribute("aria-label") or ""
            if server_name.lower() in aria_label.lower():
                target_server = el
                break

        if not target_server:
            return {
                "success": False,
                "message": f"Server '{server_name}' not found."
            }

        # Click the server
        safe_click(target_server)
        time.sleep(2)

        _discord_state["current_server"] = server_name

        return {
            "success": True,
            "message": f"Selected server: {server_name}",
            "current_url": _browser.current_url
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to select server: {str(e)}"
        }


@mcp.tool()
def get_channels() -> dict:
    """
    Get list of channels in the current server.

    Returns:
        Dict with list of channels organized by category.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        channels = []

        # Find channel elements
        channel_elements = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="channels___"]')

        for el in channel_elements:
            try:
                channel_id = el.get_attribute("data-list-item-id")
                aria_label = el.get_attribute("aria-label") or ""

                # Determine channel type from aria-label
                channel_type = "text"
                if "voice" in aria_label.lower():
                    channel_type = "voice"
                elif "stage" in aria_label.lower():
                    channel_type = "stage"
                elif "forum" in aria_label.lower():
                    channel_type = "forum"

                # Extract channel name
                name = aria_label.split(",")[0] if aria_label else el.text.strip()

                channels.append({
                    "id": channel_id,
                    "name": name,
                    "type": channel_type,
                    "has_unread": "unread" in aria_label.lower()
                })
            except:
                continue

        return {
            "success": True,
            "channels": channels,
            "count": len(channels),
            "current_server": _discord_state["current_server"]
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get channels: {str(e)}"
        }


@mcp.tool()
def select_channel(channel_name: str) -> dict:
    """
    Select a channel by name.

    Args:
        channel_name: Name of the channel to select (partial match supported).

    Returns:
        Status dict with selection result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find channel by name
        channel_elements = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="channels___"]')

        target_channel = None
        for el in channel_elements:
            aria_label = el.get_attribute("aria-label") or ""
            text = el.text.strip()
            if channel_name.lower() in aria_label.lower() or channel_name.lower() in text.lower():
                target_channel = el
                break

        if not target_channel:
            return {
                "success": False,
                "message": f"Channel '{channel_name}' not found."
            }

        # Click the channel
        safe_click(target_channel)
        time.sleep(2)

        _discord_state["current_channel"] = channel_name

        return {
            "success": True,
            "message": f"Selected channel: {channel_name}",
            "current_url": _browser.current_url
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to select channel: {str(e)}"
        }


@mcp.tool()
def navigate_to_dms() -> dict:
    """
    Navigate to Direct Messages.

    Returns:
        Status dict with navigation result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        _browser.get(DISCORD_CHANNELS_URL)
        time.sleep(3)
        wait_for_discord_load()

        _discord_state["current_server"] = "DMs"
        _discord_state["current_channel"] = None

        return {
            "success": True,
            "message": "Navigated to Direct Messages.",
            "current_url": _browser.current_url
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to navigate to DMs: {str(e)}"
        }


@mcp.tool()
def get_dm_conversations() -> dict:
    """
    Get list of DM conversations.

    Returns:
        Dict with list of DM conversations.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to DMs first
        if "@me" not in _browser.current_url:
            _browser.get(DISCORD_CHANNELS_URL)
            time.sleep(2)

        conversations = []

        # Find DM list items
        dm_elements = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="private-channels-"]')

        for el in dm_elements:
            try:
                dm_id = el.get_attribute("data-list-item-id")
                aria_label = el.get_attribute("aria-label") or ""

                conversations.append({
                    "id": dm_id,
                    "name": aria_label.split(",")[0] if aria_label else el.text.strip(),
                    "has_unread": "unread" in aria_label.lower()
                })
            except:
                continue

        return {
            "success": True,
            "conversations": conversations,
            "count": len(conversations)
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get DM conversations: {str(e)}"
        }


@mcp.tool()
def open_dm(username: str) -> dict:
    """
    Open a DM conversation with a user.

    Args:
        username: Username to open DM with (partial match supported).

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to DMs
        if "@me" not in _browser.current_url:
            _browser.get(DISCORD_CHANNELS_URL)
            time.sleep(2)

        # Find DM by username
        dm_elements = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="private-channels-"]')

        target_dm = None
        for el in dm_elements:
            aria_label = el.get_attribute("aria-label") or ""
            text = el.text.strip()
            if username.lower() in aria_label.lower() or username.lower() in text.lower():
                target_dm = el
                break

        if not target_dm:
            return {
                "success": False,
                "message": f"DM with '{username}' not found."
            }

        safe_click(target_dm)
        time.sleep(2)

        _discord_state["current_channel"] = f"DM: {username}"

        return {
            "success": True,
            "message": f"Opened DM with {username}",
            "current_url": _browser.current_url
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to open DM: {str(e)}"
        }


# ============================================================================
# Message Tools
# ============================================================================

@mcp.tool()
def get_messages(limit: int = 20) -> dict:
    """
    Get recent messages from the current channel.

    Args:
        limit: Maximum number of messages to retrieve. Default 20.

    Returns:
        Dict with list of messages.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        messages = []

        # Find message containers
        message_elements = _browser.find_elements(By.CSS_SELECTOR, '[id^="chat-messages-"]')

        for el in message_elements[-limit:]:  # Get last N messages
            try:
                msg_id = el.get_attribute("id")

                # Extract author
                author_el = el.find_elements(By.CSS_SELECTOR, '[class*="username"]')
                author = author_el[0].text if author_el else "Unknown"

                # Extract message content
                content_el = el.find_elements(By.CSS_SELECTOR, '[id^="message-content-"]')
                content = content_el[0].text if content_el else ""

                # Extract timestamp
                timestamp_el = el.find_elements(By.CSS_SELECTOR, 'time')
                timestamp = timestamp_el[0].get_attribute("datetime") if timestamp_el else None

                # Check for attachments
                attachments = el.find_elements(By.CSS_SELECTOR, '[class*="attachment"]')

                # Check for embeds
                embeds = el.find_elements(By.CSS_SELECTOR, '[class*="embed"]')

                messages.append({
                    "id": msg_id,
                    "author": author,
                    "content": content,
                    "timestamp": timestamp,
                    "has_attachments": len(attachments) > 0,
                    "has_embeds": len(embeds) > 0
                })
            except:
                continue

        return {
            "success": True,
            "messages": messages,
            "count": len(messages),
            "channel": _discord_state["current_channel"]
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get messages: {str(e)}"
        }


@mcp.tool()
def send_message(message: str) -> dict:
    """
    Send a message to the current channel.

    Args:
        message: The message text to send.

    Returns:
        Status dict with send result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find message input
        message_input = WebDriverWait(_browser, 10).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, 'div[role="textbox"]'))
        )

        # Click to focus
        message_input.click()
        time.sleep(0.5)

        # Type the message
        message_input.send_keys(message)
        time.sleep(0.5)

        # Send with Enter
        message_input.send_keys(Keys.ENTER)
        time.sleep(1)

        return {
            "success": True,
            "message": f"Message sent: {message[:50]}..." if len(message) > 50 else f"Message sent: {message}",
            "channel": _discord_state["current_channel"]
        }

    except TimeoutException:
        return {
            "success": False,
            "message": "Could not find message input. Make sure you're in a text channel."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to send message: {str(e)}"
        }


@mcp.tool()
def send_message_with_js(message: str) -> dict:
    """
    Send a message using JavaScript injection (more reliable for some cases).

    Args:
        message: The message text to send.

    Returns:
        Status dict with send result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find message input
        message_input = WebDriverWait(_browser, 10).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, 'div[role="textbox"]'))
        )

        # Use JavaScript to set content and trigger input event
        escaped_message = message.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")

        script = f'''
            const el = arguments[0];
            el.focus();
            el.textContent = "{escaped_message}";
            el.dispatchEvent(new InputEvent('input', {{bubbles: true}}));
        '''
        _browser.execute_script(script, message_input)

        time.sleep(0.5)

        # Send with Enter key
        message_input.send_keys(Keys.ENTER)
        time.sleep(1)

        return {
            "success": True,
            "message": f"Message sent via JS: {message[:50]}..." if len(message) > 50 else f"Message sent via JS: {message}",
            "channel": _discord_state["current_channel"]
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to send message: {str(e)}"
        }


@mcp.tool()
def reply_to_message(message_id: str, reply_text: str) -> dict:
    """
    Reply to a specific message.

    Args:
        message_id: The ID of the message to reply to (from get_messages).
        reply_text: The reply message text.

    Returns:
        Status dict with reply result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find the message element
        message_el = _browser.find_element(By.ID, message_id)

        # Right-click to open context menu
        actions = ActionChains(_browser)
        actions.context_click(message_el).perform()
        time.sleep(0.5)

        # Find and click Reply option
        reply_option = _browser.find_element(By.XPATH, "//*[contains(text(), 'Reply')]")
        reply_option.click()
        time.sleep(0.5)

        # Type and send reply
        message_input = _browser.find_element(By.CSS_SELECTOR, 'div[role="textbox"]')
        message_input.send_keys(reply_text)
        message_input.send_keys(Keys.ENTER)
        time.sleep(1)

        return {
            "success": True,
            "message": f"Replied to message: {reply_text[:50]}..."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to reply: {str(e)}"
        }


@mcp.tool()
def add_reaction(message_id: str, emoji: str) -> dict:
    """
    Add a reaction to a message.

    Args:
        message_id: The ID of the message to react to.
        emoji: The emoji to add (e.g., "ðŸ‘" or emoji name like "thumbsup").

    Returns:
        Status dict with reaction result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find the message element
        message_el = _browser.find_element(By.ID, message_id)

        # Hover to show reaction button
        actions = ActionChains(_browser)
        actions.move_to_element(message_el).perform()
        time.sleep(0.5)

        # Find and click add reaction button
        reaction_btn = message_el.find_element(By.CSS_SELECTOR, '[aria-label="Add Reaction"]')
        reaction_btn.click()
        time.sleep(0.5)

        # Type emoji in search
        search_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="emoji"]')
        search_input.send_keys(emoji)
        time.sleep(0.5)

        # Click first result
        first_emoji = _browser.find_element(By.CSS_SELECTOR, '[class*="emojiItem"]')
        first_emoji.click()
        time.sleep(0.5)

        return {
            "success": True,
            "message": f"Added reaction {emoji} to message."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to add reaction: {str(e)}"
        }


# ============================================================================
# Notification Tools
# ============================================================================

@mcp.tool()
def get_notifications() -> dict:
    """
    Get current notification indicators (unread channels, mentions, etc.).

    Returns:
        Dict with notification information.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        notifications = {
            "unread_channels": [],
            "mentions": [],
            "dm_notifications": [],
        }

        # Find unread indicators in server list
        server_elements = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="guildsnav___"]')
        for el in server_elements:
            aria_label = el.get_attribute("aria-label") or ""
            if "unread" in aria_label.lower() or el.find_elements(By.CSS_SELECTOR, '[class*="unread"]'):
                notifications["unread_channels"].append({
                    "server": aria_label.split(",")[0] if aria_label else "Unknown"
                })

        # Find mention badges
        mention_badges = _browser.find_elements(By.CSS_SELECTOR, '[class*="numberBadge"]')
        for badge in mention_badges:
            try:
                count = badge.text
                if count.isdigit():
                    notifications["mentions"].append({
                        "count": int(count),
                        "location": badge.get_attribute("aria-label") or "Unknown"
                    })
            except:
                continue

        # Find DM notifications
        dm_elements = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="private-channels-"]')
        for el in dm_elements:
            if el.find_elements(By.CSS_SELECTOR, '[class*="unread"]') or el.find_elements(By.CSS_SELECTOR, '[class*="numberBadge"]'):
                aria_label = el.get_attribute("aria-label") or ""
                notifications["dm_notifications"].append({
                    "user": aria_label.split(",")[0] if aria_label else el.text.strip()
                })

        return {
            "success": True,
            "notifications": notifications,
            "has_notifications": bool(notifications["unread_channels"] or notifications["mentions"] or notifications["dm_notifications"])
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get notifications: {str(e)}"
        }


@mcp.tool()
def check_mentions() -> dict:
    """
    Check for recent mentions by opening the mentions inbox.

    Returns:
        Dict with mention information.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Click inbox button
        inbox_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Inbox"]')
        inbox_btn.click()
        time.sleep(1)

        # Look for mentions tab
        try:
            mentions_tab = _browser.find_element(By.XPATH, "//*[contains(text(), 'Mentions')]")
            mentions_tab.click()
            time.sleep(1)
        except:
            pass

        mentions = []

        # Get mention items
        mention_items = _browser.find_elements(By.CSS_SELECTOR, '[class*="recentMention"]')

        for item in mention_items[:10]:  # Limit to 10
            try:
                author = item.find_element(By.CSS_SELECTOR, '[class*="username"]').text
                content = item.find_element(By.CSS_SELECTOR, '[class*="content"]').text
                server = item.find_element(By.CSS_SELECTOR, '[class*="guildName"]').text

                mentions.append({
                    "author": author,
                    "content": content[:100] + "..." if len(content) > 100 else content,
                    "server": server
                })
            except:
                continue

        # Close inbox
        try:
            close_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Close"]')
            close_btn.click()
        except:
            pass

        return {
            "success": True,
            "mentions": mentions,
            "count": len(mentions)
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to check mentions: {str(e)}"
        }


# ============================================================================
# Utility Tools
# ============================================================================

@mcp.tool()
def take_discord_screenshot(save_path: str = None) -> dict:
    """
    Take a screenshot of the current Discord page.

    Args:
        save_path: Optional file path to save the screenshot. If not provided,
                   returns base64 encoded image data.

    Returns:
        Dict with screenshot data or save confirmation.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        if save_path:
            _browser.save_screenshot(save_path)
            return {
                "success": True,
                "message": f"Screenshot saved to {save_path}",
                "path": save_path
            }
        else:
            screenshot = _browser.get_screenshot_as_base64()
            return {
                "success": True,
                "screenshot": screenshot,
                "format": "base64/png"
            }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to take screenshot: {str(e)}"
        }


@mcp.tool()
def get_current_page_info() -> dict:
    """
    Get information about the current Discord page.

    Returns:
        Dict with page information.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        return {
            "success": True,
            "url": _browser.current_url,
            "title": _browser.title,
            "state": _discord_state
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get page info: {str(e)}"
        }


@mcp.tool()
def scroll_messages(direction: str = "up", amount: int = 500) -> dict:
    """
    Scroll the message list to load older or newer messages.

    Args:
        direction: Scroll direction - "up" for older, "down" for newer.
        amount: Pixels to scroll. Default 500.

    Returns:
        Status dict with scroll result.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        # Find the scrollable message container
        scroller = _browser.find_element(By.CSS_SELECTOR, '[class*="scroller"]')

        scroll_amount = -amount if direction == "up" else amount

        _browser.execute_script(f"arguments[0].scrollTop += {scroll_amount};", scroller)
        time.sleep(1)

        return {
            "success": True,
            "message": f"Scrolled {direction} by {amount}px"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to scroll: {str(e)}"
        }


@mcp.tool()
def search_discord(query: str) -> dict:
    """
    Search in Discord (current server or global).

    Args:
        query: Search query text.

    Returns:
        Dict with search results.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Use Ctrl+K or click search
        actions = ActionChains(_browser)
        actions.key_down(Keys.CONTROL).send_keys('k').key_up(Keys.CONTROL).perform()
        time.sleep(1)

        # Find search input and enter query
        search_input = WebDriverWait(_browser, 10).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, 'input[placeholder*="Search"]'))
        )
        search_input.send_keys(query)
        search_input.send_keys(Keys.ENTER)
        time.sleep(2)

        # Collect search results
        results = []
        result_elements = _browser.find_elements(By.CSS_SELECTOR, '[class*="searchResult"]')

        for el in result_elements[:10]:
            try:
                results.append({
                    "text": el.text[:200] + "..." if len(el.text) > 200 else el.text
                })
            except:
                continue

        # Close search
        try:
            _browser.find_element(By.CSS_SELECTOR, '[aria-label="Close"]').click()
        except:
            actions.send_keys(Keys.ESCAPE).perform()

        return {
            "success": True,
            "query": query,
            "results": results,
            "count": len(results)
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Search failed: {str(e)}"
        }


@mcp.tool()
def get_user_profile(username: str) -> dict:
    """
    Get information about a user by clicking on their name in chat.

    Args:
        username: Username to look up.

    Returns:
        Dict with user profile information.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        # Find username in messages
        user_elements = _browser.find_elements(By.XPATH, f"//*[contains(@class, 'username') and contains(text(), '{username}')]")

        if not user_elements:
            return {
                "success": False,
                "message": f"User '{username}' not found in current chat."
            }

        # Click on username
        safe_click(user_elements[0])
        time.sleep(1)

        # Extract profile info from popup
        profile_info = {}

        try:
            profile_card = _browser.find_element(By.CSS_SELECTOR, '[class*="userPopout"]')

            # Get display name
            display_name = profile_card.find_elements(By.CSS_SELECTOR, '[class*="nickname"]')
            if display_name:
                profile_info["display_name"] = display_name[0].text

            # Get username
            username_el = profile_card.find_elements(By.CSS_SELECTOR, '[class*="username"]')
            if username_el:
                profile_info["username"] = username_el[0].text

            # Get status
            status_el = profile_card.find_elements(By.CSS_SELECTOR, '[class*="customStatus"]')
            if status_el:
                profile_info["status"] = status_el[0].text

            # Get roles
            roles = profile_card.find_elements(By.CSS_SELECTOR, '[class*="role"]')
            profile_info["roles"] = [r.text for r in roles if r.text]

        except:
            pass

        # Close popup
        try:
            _browser.find_element(By.CSS_SELECTOR, 'body').click()
        except:
            pass

        return {
            "success": True,
            "profile": profile_info
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get profile: {str(e)}"
        }


@mcp.tool()
def set_status(status: str, custom_status: str = None) -> dict:
    """
    Set your Discord status.

    Args:
        status: Status type - "online", "idle", "dnd" (Do Not Disturb), "invisible".
        custom_status: Optional custom status text.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Click on user area at bottom
        user_area = _browser.find_element(By.CSS_SELECTOR, '[aria-label*="Set Status"]')
        user_area.click()
        time.sleep(0.5)

        # Map status to menu option
        status_map = {
            "online": "Online",
            "idle": "Idle",
            "dnd": "Do Not Disturb",
            "invisible": "Invisible"
        }

        target_status = status_map.get(status.lower(), "Online")

        # Find and click status option
        status_option = _browser.find_element(By.XPATH, f"//*[contains(text(), '{target_status}')]")
        status_option.click()
        time.sleep(0.5)

        # Set custom status if provided
        if custom_status:
            try:
                custom_btn = _browser.find_element(By.XPATH, "//*[contains(text(), 'Set Custom Status')]")
                custom_btn.click()
                time.sleep(0.5)

                custom_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="status"]')
                custom_input.clear()
                custom_input.send_keys(custom_status)

                save_btn = _browser.find_element(By.XPATH, "//button[contains(text(), 'Save')]")
                save_btn.click()
            except:
                pass

        return {
            "success": True,
            "message": f"Status set to {target_status}" + (f" with custom: {custom_status}" if custom_status else "")
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to set status: {str(e)}"
        }


@mcp.tool()
def join_voice_channel(channel_name: str) -> dict:
    """
    Join a voice channel (note: audio won't work in headless mode).

    Args:
        channel_name: Name of the voice channel to join.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find voice channel
        channels = _browser.find_elements(By.CSS_SELECTOR, '[data-list-item-id^="channels___"]')

        target_channel = None
        for ch in channels:
            aria_label = ch.get_attribute("aria-label") or ""
            if channel_name.lower() in aria_label.lower() and "voice" in aria_label.lower():
                target_channel = ch
                break

        if not target_channel:
            return {
                "success": False,
                "message": f"Voice channel '{channel_name}' not found."
            }

        # Double-click to join
        actions = ActionChains(_browser)
        actions.double_click(target_channel).perform()
        time.sleep(2)

        return {
            "success": True,
            "message": f"Joined voice channel: {channel_name}",
            "note": "Audio functionality may be limited in headless mode."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to join voice channel: {str(e)}"
        }


@mcp.tool()
def leave_voice_channel() -> dict:
    """
    Leave the current voice channel.

    Returns:
        Status dict with result.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        # Find disconnect button
        disconnect_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Disconnect"]')
        disconnect_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": "Left voice channel."
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": "Not in a voice channel."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to leave voice channel: {str(e)}"
        }


@mcp.tool()
def mute_unmute() -> dict:
    """
    Toggle mute in voice channel.

    Returns:
        Status dict with result.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        mute_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label*="Mute"]')
        mute_btn.click()
        time.sleep(0.5)

        # Check new state
        new_state = "muted" if "Unmute" in mute_btn.get_attribute("aria-label") else "unmuted"

        return {
            "success": True,
            "message": f"Microphone is now {new_state}."
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": "Not in a voice channel or mute button not found."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to toggle mute: {str(e)}"
        }


@mcp.tool()
def execute_discord_js(script: str) -> dict:
    """
    Execute custom JavaScript in the Discord context.

    Args:
        script: JavaScript code to execute.

    Returns:
        Dict with script result.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        result = _browser.execute_script(script)
        return {
            "success": True,
            "result": str(result) if result else None
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Script execution failed: {str(e)}"
        }


@mcp.tool()
def wait_for_element(
    selector: str,
    by: str = "css",
    timeout: int = 10,
    condition: str = "present"
) -> dict:
    """
    Wait for an element to appear on the page.

    Args:
        selector: Element selector.
        by: Selector strategy - "css", "xpath", "id", etc. Default "css".
        timeout: Maximum wait time in seconds. Default 10.
        condition: Wait condition - "present", "visible", "clickable". Default "present".

    Returns:
        Dict with element info if found.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        by_strategy = get_by_strategy(by)

        conditions = {
            "present": EC.presence_of_element_located,
            "visible": EC.visibility_of_element_located,
            "clickable": EC.element_to_be_clickable,
        }

        wait_condition = conditions.get(condition, EC.presence_of_element_located)

        element = WebDriverWait(_browser, timeout).until(
            wait_condition((by_strategy, selector))
        )

        return {
            "success": True,
            "element": element_to_dict(element)
        }

    except TimeoutException:
        return {
            "success": False,
            "message": f"Timeout waiting for element: {selector}"
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Wait failed: {str(e)}"
        }


# ============================================================================
# 2FA / TOTP Tools
# ============================================================================

@mcp.tool()
def generate_totp_code(secret: str) -> dict:
    """
    Generate a TOTP code from a secret key for 2FA authentication.

    Args:
        secret: The TOTP secret key (base32 encoded string from Discord).

    Returns:
        Dict with the generated TOTP code and remaining validity time.
    """
    try:
        import pyotp

        totp = pyotp.TOTP(secret)
        code = totp.now()

        # Calculate remaining validity time
        import time as time_module
        remaining = 30 - (int(time_module.time()) % 30)

        return {
            "success": True,
            "code": code,
            "remaining_seconds": remaining,
            "message": f"TOTP code generated. Valid for {remaining} more seconds."
        }

    except ImportError:
        return {
            "success": False,
            "message": "pyotp not installed. Run: pip install pyotp"
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to generate TOTP: {str(e)}"
        }


@mcp.tool()
def discord_login_with_totp(
    email: str,
    password: str,
    totp_secret: str,
    timeout: int = 30,
) -> dict:
    """
    Login to Discord with email, password, and automatic TOTP 2FA code generation.

    This is a convenience function that combines login and 2FA in one step.

    Args:
        email: Discord account email or phone number.
        password: Discord account password.
        totp_secret: The TOTP secret key for generating 2FA codes.
        timeout: Maximum time to wait for login in seconds. Default 30.

    Returns:
        Status dict with login result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {
            "success": False,
            "message": "Browser not running. Call start_discord_browser first."
        }

    try:
        import pyotp
    except ImportError:
        return {
            "success": False,
            "message": "pyotp not installed. Run: pip install pyotp"
        }

    try:
        # First, attempt regular login
        login_result = discord_login(email, password, timeout)

        # If login succeeded without 2FA, return
        if login_result.get("success"):
            return login_result

        # If 2FA is required, generate and submit code
        if login_result.get("requires_2fa"):
            # Generate TOTP code
            totp = pyotp.TOTP(totp_secret)
            code = totp.now()

            # Submit 2FA code
            twofa_result = discord_submit_2fa(code, timeout)
            return twofa_result

        # Otherwise, return the original error
        return login_result

    except Exception as e:
        return {
            "success": False,
            "message": f"Login with TOTP failed: {str(e)}"
        }


# ============================================================================
# Additional Automation Tools
# ============================================================================

@mcp.tool()
def get_channel_by_id(channel_id: str) -> dict:
    """
    Navigate to a specific channel by its Discord ID.

    Args:
        channel_id: The Discord channel ID (snowflake).

    Returns:
        Status dict with navigation result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Construct channel URL
        # Format: https://discord.com/channels/@me/CHANNEL_ID or
        #         https://discord.com/channels/SERVER_ID/CHANNEL_ID
        _browser.get(f"https://discord.com/channels/@me/{channel_id}")
        time.sleep(3)

        wait_for_discord_load()

        return {
            "success": True,
            "message": f"Navigated to channel {channel_id}",
            "current_url": _browser.current_url
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to navigate to channel: {str(e)}"
        }


@mcp.tool()
def get_server_by_id(server_id: str, channel_id: str = None) -> dict:
    """
    Navigate to a specific server (and optionally channel) by Discord ID.

    Args:
        server_id: The Discord server/guild ID (snowflake).
        channel_id: Optional channel ID to navigate to within the server.

    Returns:
        Status dict with navigation result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Construct URL
        if channel_id:
            url = f"https://discord.com/channels/{server_id}/{channel_id}"
        else:
            url = f"https://discord.com/channels/{server_id}"

        _browser.get(url)
        time.sleep(3)

        wait_for_discord_load()

        return {
            "success": True,
            "message": f"Navigated to server {server_id}",
            "current_url": _browser.current_url
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to navigate to server: {str(e)}"
        }


@mcp.tool()
def get_pinned_messages() -> dict:
    """
    Get pinned messages in the current channel.

    Returns:
        Dict with list of pinned messages.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Click pinned messages button
        pinned_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Pinned Messages"]')
        pinned_btn.click()
        time.sleep(1)

        pinned_messages = []

        # Find pinned message elements
        pin_elements = _browser.find_elements(By.CSS_SELECTOR, '[class*="messageListItem"]')

        for el in pin_elements[:20]:  # Limit to 20
            try:
                author = el.find_element(By.CSS_SELECTOR, '[class*="username"]').text
                content = el.find_element(By.CSS_SELECTOR, '[class*="content"]').text

                pinned_messages.append({
                    "author": author,
                    "content": content[:200] + "..." if len(content) > 200 else content
                })
            except:
                continue

        # Close pinned panel
        try:
            _browser.find_element(By.CSS_SELECTOR, '[aria-label="Close"]').click()
        except:
            pass

        return {
            "success": True,
            "pinned_messages": pinned_messages,
            "count": len(pinned_messages)
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": "Pinned messages button not found. Make sure you're in a text channel."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get pinned messages: {str(e)}"
        }


@mcp.tool()
def get_member_list() -> dict:
    """
    Get the member list of the current server/channel.

    Returns:
        Dict with list of visible members.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        members = []

        # Find member list items
        member_elements = _browser.find_elements(By.CSS_SELECTOR, '[class*="member-"]')

        for el in member_elements[:50]:  # Limit to 50
            try:
                username = el.find_element(By.CSS_SELECTOR, '[class*="username"]').text

                # Try to get status
                status = "offline"
                if el.find_elements(By.CSS_SELECTOR, '[class*="online"]'):
                    status = "online"
                elif el.find_elements(By.CSS_SELECTOR, '[class*="idle"]'):
                    status = "idle"
                elif el.find_elements(By.CSS_SELECTOR, '[class*="dnd"]'):
                    status = "dnd"

                members.append({
                    "username": username,
                    "status": status
                })
            except:
                continue

        return {
            "success": True,
            "members": members,
            "count": len(members)
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get member list: {str(e)}"
        }


@mcp.tool()
def send_file(file_path: str, message: str = "") -> dict:
    """
    Send a file to the current channel.

    Args:
        file_path: Absolute path to the file to upload.
        message: Optional message to send with the file.

    Returns:
        Status dict with upload result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    if not os.path.exists(file_path):
        return {"success": False, "message": f"File not found: {file_path}"}

    try:
        # Find the file input
        file_input = _browser.find_element(By.CSS_SELECTOR, 'input[type="file"]')

        # Send file path to input
        file_input.send_keys(file_path)
        time.sleep(2)

        # Add optional message
        if message:
            message_input = _browser.find_element(By.CSS_SELECTOR, 'div[role="textbox"]')
            message_input.send_keys(message)

        # Click upload/send button
        upload_btn = _browser.find_element(By.CSS_SELECTOR, 'button[type="submit"]')
        upload_btn.click()
        time.sleep(2)

        return {
            "success": True,
            "message": f"File uploaded: {os.path.basename(file_path)}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to send file: {str(e)}"
        }


@mcp.tool()
def create_thread(message_id: str, thread_name: str) -> dict:
    """
    Create a thread from a message.

    Args:
        message_id: The ID of the message to create a thread from.
        thread_name: Name for the new thread.

    Returns:
        Status dict with thread creation result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find and right-click message
        message_el = _browser.find_element(By.ID, message_id)
        actions = ActionChains(_browser)
        actions.context_click(message_el).perform()
        time.sleep(0.5)

        # Find and click "Create Thread"
        thread_option = _browser.find_element(By.XPATH, "//*[contains(text(), 'Create Thread')]")
        thread_option.click()
        time.sleep(1)

        # Enter thread name
        name_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="name"]')
        name_input.clear()
        name_input.send_keys(thread_name)

        # Create thread
        create_btn = _browser.find_element(By.XPATH, "//button[contains(text(), 'Create Thread')]")
        create_btn.click()
        time.sleep(2)

        return {
            "success": True,
            "message": f"Thread created: {thread_name}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to create thread: {str(e)}"
        }


@mcp.tool()
def mark_as_read() -> dict:
    """
    Mark the current channel as read.

    Returns:
        Status dict with result.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        # Use keyboard shortcut Escape to mark as read
        actions = ActionChains(_browser)
        actions.send_keys(Keys.ESCAPE).perform()
        time.sleep(0.5)

        return {
            "success": True,
            "message": "Channel marked as read."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to mark as read: {str(e)}"
        }


@mcp.tool()
def open_settings(section: str = None) -> dict:
    """
    Open Discord settings.

    Args:
        section: Optional settings section to navigate to (e.g., "Privacy", "Appearance").

    Returns:
        Status dict with result.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        # Click user settings
        settings_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="User Settings"]')
        settings_btn.click()
        time.sleep(1)

        # Navigate to specific section if requested
        if section:
            try:
                section_el = _browser.find_element(By.XPATH, f"//*[contains(text(), '{section}')]")
                section_el.click()
                time.sleep(0.5)
            except:
                pass

        return {
            "success": True,
            "message": f"Settings opened" + (f" at section: {section}" if section else "")
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to open settings: {str(e)}"
        }


@mcp.tool()
def close_settings() -> dict:
    """
    Close Discord settings/modals.

    Returns:
        Status dict with result.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        # Press Escape to close
        actions = ActionChains(_browser)
        actions.send_keys(Keys.ESCAPE).perform()
        time.sleep(0.5)

        return {
            "success": True,
            "message": "Settings/modal closed."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to close settings: {str(e)}"
        }


# ============================================================================
# Friend Management Tools
# ============================================================================

@mcp.tool()
def add_friend(username: str) -> dict:
    """
    Send a friend request to a user.

    Args:
        username: The username to add (format: username or username#0000).

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to Friends page
        _browser.get("https://discord.com/channels/@me")
        time.sleep(2)

        # Click Add Friend button
        add_btn = WebDriverWait(_browser, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Add Friend')]"))
        )
        add_btn.click()
        time.sleep(1)

        # Find username input
        username_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="username" i]')
        username_input.clear()
        username_input.send_keys(username)

        # Click Send Friend Request
        send_btn = _browser.find_element(By.XPATH, "//button[contains(., 'Send Friend Request')]")
        send_btn.click()
        time.sleep(1)

        # Check for success/error message
        page_text = _browser.page_source.lower()
        if "success" in page_text or "sent" in page_text:
            return {
                "success": True,
                "message": f"Friend request sent to {username}"
            }
        elif "invalid" in page_text or "not found" in page_text:
            return {
                "success": False,
                "message": f"User '{username}' not found or invalid format."
            }

        return {
            "success": True,
            "message": f"Friend request may have been sent to {username}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to add friend: {str(e)}"
        }


@mcp.tool()
def get_friend_requests() -> dict:
    """
    Get pending friend requests (incoming and outgoing).

    Returns:
        Dict with lists of incoming and outgoing requests.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to Friends -> Pending
        _browser.get("https://discord.com/channels/@me")
        time.sleep(2)

        # Click Pending tab
        pending_btn = _browser.find_element(By.XPATH, "//div[contains(text(), 'Pending')]")
        pending_btn.click()
        time.sleep(1)

        requests = {
            "incoming": [],
            "outgoing": []
        }

        # Find request items
        request_items = _browser.find_elements(By.CSS_SELECTOR, '[class*="peopleListItem"]')

        for item in request_items:
            try:
                username = item.find_element(By.CSS_SELECTOR, '[class*="username"]').text

                # Check if incoming (has Accept button) or outgoing
                if item.find_elements(By.XPATH, ".//button[contains(., 'Accept')]"):
                    requests["incoming"].append({"username": username})
                else:
                    requests["outgoing"].append({"username": username})
            except:
                continue

        return {
            "success": True,
            "requests": requests,
            "incoming_count": len(requests["incoming"]),
            "outgoing_count": len(requests["outgoing"])
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get friend requests: {str(e)}"
        }


@mcp.tool()
def accept_friend_request(username: str) -> dict:
    """
    Accept a pending friend request.

    Args:
        username: Username of the person whose request to accept.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to Friends -> Pending
        _browser.get("https://discord.com/channels/@me")
        time.sleep(2)

        pending_btn = _browser.find_element(By.XPATH, "//div[contains(text(), 'Pending')]")
        pending_btn.click()
        time.sleep(1)

        # Find the request and click Accept
        request_item = _browser.find_element(
            By.XPATH,
            f"//div[contains(@class, 'peopleListItem') and .//span[contains(text(), '{username}')]]"
        )
        accept_btn = request_item.find_element(By.XPATH, ".//button[contains(., 'Accept') or @aria-label='Accept']")
        accept_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": f"Accepted friend request from {username}"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": f"Friend request from '{username}' not found."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to accept request: {str(e)}"
        }


@mcp.tool()
def decline_friend_request(username: str) -> dict:
    """
    Decline a pending friend request.

    Args:
        username: Username of the person whose request to decline.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to Friends -> Pending
        _browser.get("https://discord.com/channels/@me")
        time.sleep(2)

        pending_btn = _browser.find_element(By.XPATH, "//div[contains(text(), 'Pending')]")
        pending_btn.click()
        time.sleep(1)

        # Find the request and click Ignore/Decline
        request_item = _browser.find_element(
            By.XPATH,
            f"//div[contains(@class, 'peopleListItem') and .//span[contains(text(), '{username}')]]"
        )
        decline_btn = request_item.find_element(By.XPATH, ".//button[contains(., 'Ignore') or @aria-label='Ignore']")
        decline_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": f"Declined friend request from {username}"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": f"Friend request from '{username}' not found."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to decline request: {str(e)}"
        }


@mcp.tool()
def remove_friend(username: str) -> dict:
    """
    Remove a friend from friends list.

    Args:
        username: Username of the friend to remove.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to Friends -> All
        _browser.get("https://discord.com/channels/@me")
        time.sleep(2)

        all_btn = _browser.find_element(By.XPATH, "//div[contains(text(), 'All')]")
        all_btn.click()
        time.sleep(1)

        # Find friend and right-click for context menu
        friend_item = _browser.find_element(
            By.XPATH,
            f"//div[contains(@class, 'peopleListItem') and .//span[contains(text(), '{username}')]]"
        )

        actions = ActionChains(_browser)
        actions.context_click(friend_item).perform()
        time.sleep(0.5)

        # Click Remove Friend
        remove_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Remove Friend')]")
        remove_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": f"Removed {username} from friends"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": f"Friend '{username}' not found."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to remove friend: {str(e)}"
        }


@mcp.tool()
def block_user(username: str) -> dict:
    """
    Block a user.

    Args:
        username: Username of the user to block.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Try to find user in current context and right-click
        user_elements = _browser.find_elements(
            By.XPATH,
            f"//*[contains(@class, 'username') and contains(text(), '{username}')]"
        )

        if not user_elements:
            return {
                "success": False,
                "message": f"User '{username}' not found in current view. Navigate to a conversation with them first."
            }

        actions = ActionChains(_browser)
        actions.context_click(user_elements[0]).perform()
        time.sleep(0.5)

        # Click Block
        block_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Block')]")
        block_btn.click()
        time.sleep(1)

        # Confirm if dialog appears
        try:
            confirm_btn = _browser.find_element(By.XPATH, "//div[@role='dialog']//button[contains(text(), 'Block')]")
            confirm_btn.click()
            time.sleep(0.5)
        except:
            pass

        return {
            "success": True,
            "message": f"Blocked user: {username}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to block user: {str(e)}"
        }


@mcp.tool()
def unblock_user(username: str) -> dict:
    """
    Unblock a user from the blocked list.

    Args:
        username: Username of the user to unblock.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to Friends -> Blocked
        _browser.get("https://discord.com/channels/@me")
        time.sleep(2)

        blocked_btn = _browser.find_element(By.XPATH, "//div[contains(text(), 'Blocked')]")
        blocked_btn.click()
        time.sleep(1)

        # Find blocked user and unblock
        blocked_item = _browser.find_element(
            By.XPATH,
            f"//div[contains(@class, 'peopleListItem') and .//span[contains(text(), '{username}')]]"
        )
        unblock_btn = blocked_item.find_element(By.XPATH, ".//button[contains(., 'Unblock')]")
        unblock_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": f"Unblocked user: {username}"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": f"User '{username}' not found in blocked list."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to unblock user: {str(e)}"
        }


@mcp.tool()
def get_friends_list() -> dict:
    """
    Get the full friends list.

    Returns:
        Dict with list of friends and their status.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to Friends -> All
        _browser.get("https://discord.com/channels/@me")
        time.sleep(2)

        all_btn = _browser.find_element(By.XPATH, "//div[contains(text(), 'All')]")
        all_btn.click()
        time.sleep(1)

        friends = []

        # Find friend items
        friend_items = _browser.find_elements(By.CSS_SELECTOR, '[class*="peopleListItem"]')

        for item in friend_items[:100]:  # Limit to 100
            try:
                username = item.find_element(By.CSS_SELECTOR, '[class*="username"]').text

                # Try to get status
                status = "offline"
                status_el = item.find_elements(By.CSS_SELECTOR, '[class*="status"]')
                if status_el:
                    status_class = status_el[0].get_attribute("class") or ""
                    if "online" in status_class.lower():
                        status = "online"
                    elif "idle" in status_class.lower():
                        status = "idle"
                    elif "dnd" in status_class.lower():
                        status = "dnd"

                friends.append({
                    "username": username,
                    "status": status
                })
            except:
                continue

        return {
            "success": True,
            "friends": friends,
            "count": len(friends)
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get friends list: {str(e)}"
        }


# ============================================================================
# Message Management Tools
# ============================================================================

@mcp.tool()
def edit_message(message_id: str, new_content: str) -> dict:
    """
    Edit one of your own messages.

    Args:
        message_id: The ID of the message to edit (from get_messages).
        new_content: The new message content.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find the message
        message_el = _browser.find_element(By.ID, message_id)

        # Hover and click more button
        actions = ActionChains(_browser)
        actions.move_to_element(message_el).perform()
        time.sleep(0.5)

        more_btn = message_el.find_element(By.CSS_SELECTOR, '[aria-label="More"]')
        more_btn.click()
        time.sleep(0.5)

        # Click Edit Message
        edit_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Edit Message')]")
        edit_btn.click()
        time.sleep(0.5)

        # Find edit textarea and update content
        edit_box = _browser.find_element(By.CSS_SELECTOR, 'div[role="textbox"][contenteditable="true"]')
        edit_box.clear()

        # Use JS to set content
        escaped = new_content.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")
        _browser.execute_script(f'arguments[0].textContent = "{escaped}";', edit_box)
        edit_box.send_keys(Keys.ENTER)
        time.sleep(1)

        return {
            "success": True,
            "message": f"Message edited successfully"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": "Message not found or edit option not available (you can only edit your own messages)."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to edit message: {str(e)}"
        }


@mcp.tool()
def delete_message(message_id: str) -> dict:
    """
    Delete a message.

    Args:
        message_id: The ID of the message to delete.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find the message
        message_el = _browser.find_element(By.ID, message_id)

        # Hover and click more button
        actions = ActionChains(_browser)
        actions.move_to_element(message_el).perform()
        time.sleep(0.5)

        more_btn = message_el.find_element(By.CSS_SELECTOR, '[aria-label="More"]')
        more_btn.click()
        time.sleep(0.5)

        # Click Delete Message
        delete_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Delete Message')]")
        delete_btn.click()
        time.sleep(0.5)

        # Confirm deletion
        confirm_btn = _browser.find_element(By.XPATH, "//div[@role='dialog']//button[contains(text(), 'Delete')]")
        confirm_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": "Message deleted successfully"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": "Message not found or delete option not available."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to delete message: {str(e)}"
        }


@mcp.tool()
def pin_message(message_id: str) -> dict:
    """
    Pin a message in the current channel.

    Args:
        message_id: The ID of the message to pin.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find the message
        message_el = _browser.find_element(By.ID, message_id)

        # Hover and click more button
        actions = ActionChains(_browser)
        actions.move_to_element(message_el).perform()
        time.sleep(0.5)

        more_btn = message_el.find_element(By.CSS_SELECTOR, '[aria-label="More"]')
        more_btn.click()
        time.sleep(0.5)

        # Click Pin Message
        pin_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Pin Message')]")
        pin_btn.click()
        time.sleep(0.5)

        # Confirm if dialog appears
        try:
            confirm_btn = _browser.find_element(By.XPATH, "//div[@role='dialog']//button[contains(text(), 'Oh yeah')]")
            confirm_btn.click()
        except:
            pass

        time.sleep(0.5)

        return {
            "success": True,
            "message": "Message pinned successfully"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": "Message not found or pin option not available."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to pin message: {str(e)}"
        }


@mcp.tool()
def unpin_message(message_id: str) -> dict:
    """
    Unpin a message from the current channel.

    Args:
        message_id: The ID of the message to unpin.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find the message
        message_el = _browser.find_element(By.ID, message_id)

        # Hover and click more button
        actions = ActionChains(_browser)
        actions.move_to_element(message_el).perform()
        time.sleep(0.5)

        more_btn = message_el.find_element(By.CSS_SELECTOR, '[aria-label="More"]')
        more_btn.click()
        time.sleep(0.5)

        # Click Unpin Message
        unpin_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Unpin Message')]")
        unpin_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": "Message unpinned successfully"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": "Message not found or unpin option not available."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to unpin message: {str(e)}"
        }


@mcp.tool()
def copy_message_link(message_id: str) -> dict:
    """
    Get the link to a specific message.

    Args:
        message_id: The ID of the message.

    Returns:
        Dict with message link.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Extract message ID from element ID and construct URL
        # Message IDs are in format: chat-messages-SNOWFLAKE
        parts = message_id.split("-")
        if len(parts) >= 3:
            msg_snowflake = parts[-1]
        else:
            msg_snowflake = message_id

        current_url = _browser.current_url
        # URL format: https://discord.com/channels/SERVER_ID/CHANNEL_ID/MESSAGE_ID

        if "/channels/" in current_url:
            base_url = current_url.split("?")[0]
            message_url = f"{base_url}/{msg_snowflake}"

            return {
                "success": True,
                "message_url": message_url,
                "message_id": msg_snowflake
            }

        return {
            "success": False,
            "message": "Could not construct message URL from current page."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get message link: {str(e)}"
        }


# ============================================================================
# Channel Management Tools
# ============================================================================

@mcp.tool()
def create_channel(channel_name: str, channel_type: str = "text", category: str = None) -> dict:
    """
    Create a new channel in the current server.

    Args:
        channel_name: Name for the new channel.
        channel_type: Type of channel - "text", "voice", "announcement", "forum". Default "text".
        category: Optional category to create the channel under.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find create channel button (+ next to category or server)
        if category:
            # Find category and its + button
            category_el = _browser.find_element(
                By.XPATH,
                f"//div[contains(@class, 'category') and .//span[contains(text(), '{category}')]]"
            )
            create_btn = category_el.find_element(By.CSS_SELECTOR, '[aria-label="Create Channel"]')
        else:
            # Use server-level create button
            create_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Create Channel"]')

        create_btn.click()
        time.sleep(1)

        # Select channel type
        type_map = {
            "text": "Text",
            "voice": "Voice",
            "announcement": "Announcement",
            "forum": "Forum"
        }
        type_label = type_map.get(channel_type.lower(), "Text")

        type_btn = _browser.find_element(By.XPATH, f"//div[contains(text(), '{type_label}')]")
        type_btn.click()
        time.sleep(0.5)

        # Enter channel name
        name_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="channel-name" i]')
        name_input.clear()
        name_input.send_keys(channel_name)

        # Click Create Channel button
        create_confirm = _browser.find_element(By.XPATH, "//button[contains(text(), 'Create Channel')]")
        create_confirm.click()
        time.sleep(2)

        return {
            "success": True,
            "message": f"Created {channel_type} channel: {channel_name}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to create channel: {str(e)}"
        }


@mcp.tool()
def delete_channel(channel_name: str) -> dict:
    """
    Delete a channel from the current server.

    Args:
        channel_name: Name of the channel to delete.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # First select the channel
        result = select_channel(channel_name)
        if not result.get("success"):
            return result

        time.sleep(1)

        # Click channel settings (gear icon in header)
        settings_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Edit Channel"]')
        settings_btn.click()
        time.sleep(1)

        # Find and click Delete Channel
        delete_btn = _browser.find_element(By.XPATH, "//div[contains(text(), 'Delete Channel')]")
        delete_btn.click()
        time.sleep(0.5)

        # Confirm deletion (type channel name)
        confirm_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="channel" i]')
        confirm_input.send_keys(channel_name)

        final_delete = _browser.find_element(By.XPATH, "//button[contains(text(), 'Delete Channel')]")
        final_delete.click()
        time.sleep(2)

        return {
            "success": True,
            "message": f"Deleted channel: {channel_name}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to delete channel: {str(e)}"
        }


@mcp.tool()
def edit_channel(channel_name: str, new_name: str = None, topic: str = None) -> dict:
    """
    Edit a channel's settings.

    Args:
        channel_name: Name of the channel to edit.
        new_name: Optional new name for the channel.
        topic: Optional new topic/description for the channel.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Select the channel
        result = select_channel(channel_name)
        if not result.get("success"):
            return result

        time.sleep(1)

        # Click channel settings
        settings_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Edit Channel"]')
        settings_btn.click()
        time.sleep(1)

        changes_made = []

        # Update name if provided
        if new_name:
            name_input = _browser.find_element(By.CSS_SELECTOR, 'input[aria-label*="Channel Name" i]')
            name_input.clear()
            name_input.send_keys(new_name)
            changes_made.append(f"name: {new_name}")

        # Update topic if provided
        if topic:
            topic_input = _browser.find_element(By.CSS_SELECTOR, 'textarea[aria-label*="Topic" i]')
            topic_input.clear()
            topic_input.send_keys(topic)
            changes_made.append(f"topic: {topic[:30]}...")

        # Save changes
        save_btn = _browser.find_element(By.XPATH, "//button[contains(text(), 'Save Changes')]")
        save_btn.click()
        time.sleep(1)

        # Close settings
        _browser.find_element(By.CSS_SELECTOR, '[aria-label="Close"]').click()

        return {
            "success": True,
            "message": f"Channel updated: {', '.join(changes_made) if changes_made else 'no changes'}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to edit channel: {str(e)}"
        }


# ============================================================================
# Server Management Tools
# ============================================================================

@mcp.tool()
def create_invite(max_age: int = 86400, max_uses: int = 0) -> dict:
    """
    Create an invite link for the current channel/server.

    Args:
        max_age: Invite expiration in seconds (0 = never, 86400 = 1 day). Default 1 day.
        max_uses: Maximum uses (0 = unlimited). Default unlimited.

    Returns:
        Dict with invite link.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Right-click on current channel to get invite option
        channel_header = _browser.find_element(By.CSS_SELECTOR, '[class*="title-"]')

        actions = ActionChains(_browser)
        actions.context_click(channel_header).perform()
        time.sleep(0.5)

        # Click Invite People
        invite_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Invite')]")
        invite_btn.click()
        time.sleep(1)

        # Get the invite link
        invite_input = _browser.find_element(By.CSS_SELECTOR, 'input[readonly][value*="discord"]')
        invite_link = invite_input.get_attribute("value")

        # Close dialog
        try:
            _browser.find_element(By.CSS_SELECTOR, '[aria-label="Close"]').click()
        except:
            pass

        return {
            "success": True,
            "invite_link": invite_link,
            "message": "Invite link created"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to create invite: {str(e)}"
        }


@mcp.tool()
def kick_member(username: str, reason: str = None) -> dict:
    """
    Kick a member from the server.

    Args:
        username: Username of the member to kick.
        reason: Optional reason for the kick.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find user in member list or message
        user_el = _browser.find_element(
            By.XPATH,
            f"//*[contains(@class, 'username') and contains(text(), '{username}')]"
        )

        # Right-click for context menu
        actions = ActionChains(_browser)
        actions.context_click(user_el).perform()
        time.sleep(0.5)

        # Click Kick
        kick_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Kick')]")
        kick_btn.click()
        time.sleep(0.5)

        # Add reason if provided
        if reason:
            reason_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="reason" i]')
            reason_input.send_keys(reason)

        # Confirm kick
        confirm_btn = _browser.find_element(By.XPATH, "//div[@role='dialog']//button[contains(text(), 'Kick')]")
        confirm_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": f"Kicked user: {username}" + (f" (Reason: {reason})" if reason else "")
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": f"User '{username}' not found or you don't have kick permissions."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to kick member: {str(e)}"
        }


@mcp.tool()
def ban_member(username: str, reason: str = None, delete_messages: int = 0) -> dict:
    """
    Ban a member from the server.

    Args:
        username: Username of the member to ban.
        reason: Optional reason for the ban.
        delete_messages: Days of messages to delete (0-7). Default 0.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find user
        user_el = _browser.find_element(
            By.XPATH,
            f"//*[contains(@class, 'username') and contains(text(), '{username}')]"
        )

        # Right-click for context menu
        actions = ActionChains(_browser)
        actions.context_click(user_el).perform()
        time.sleep(0.5)

        # Click Ban
        ban_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Ban')]")
        ban_btn.click()
        time.sleep(0.5)

        # Add reason if provided
        if reason:
            reason_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="reason" i]')
            reason_input.send_keys(reason)

        # Select message deletion if requested
        if delete_messages > 0:
            delete_select = _browser.find_element(By.CSS_SELECTOR, 'select, [role="listbox"]')
            delete_select.click()
            time.sleep(0.3)
            option = _browser.find_element(By.XPATH, f"//option[contains(text(), '{delete_messages}')]")
            option.click()

        # Confirm ban
        confirm_btn = _browser.find_element(By.XPATH, "//div[@role='dialog']//button[contains(text(), 'Ban')]")
        confirm_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": f"Banned user: {username}" + (f" (Reason: {reason})" if reason else "")
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": f"User '{username}' not found or you don't have ban permissions."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to ban member: {str(e)}"
        }


@mcp.tool()
def timeout_member(username: str, duration: str = "60s", reason: str = None) -> dict:
    """
    Timeout a member (temporarily mute them).

    Args:
        username: Username of the member to timeout.
        duration: Timeout duration (e.g., "60s", "5m", "1h", "1d", "1w"). Default "60s".
        reason: Optional reason for the timeout.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find user
        user_el = _browser.find_element(
            By.XPATH,
            f"//*[contains(@class, 'username') and contains(text(), '{username}')]"
        )

        # Right-click for context menu
        actions = ActionChains(_browser)
        actions.context_click(user_el).perform()
        time.sleep(0.5)

        # Click Timeout
        timeout_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Timeout')]")
        timeout_btn.click()
        time.sleep(0.5)

        # Select duration
        duration_map = {
            "60s": "60 Seconds",
            "5m": "5 Minutes",
            "10m": "10 Minutes",
            "1h": "1 Hour",
            "1d": "1 Day",
            "1w": "1 Week"
        }
        duration_text = duration_map.get(duration, "60 Seconds")

        duration_btn = _browser.find_element(By.XPATH, f"//div[contains(text(), '{duration_text}')]")
        duration_btn.click()
        time.sleep(0.3)

        # Add reason if provided
        if reason:
            reason_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="reason" i]')
            reason_input.send_keys(reason)

        # Confirm timeout
        confirm_btn = _browser.find_element(By.XPATH, "//button[contains(text(), 'Time')]")
        confirm_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": f"Timed out {username} for {duration}"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": f"User '{username}' not found or you don't have timeout permissions."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to timeout member: {str(e)}"
        }


@mcp.tool()
def get_server_settings() -> dict:
    """
    Get current server settings/info.

    Returns:
        Dict with server information.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Click server name to open dropdown
        server_header = _browser.find_element(By.CSS_SELECTOR, '[class*="header-"] [class*="name-"]')
        server_name = server_header.text
        server_header.click()
        time.sleep(0.5)

        # Click Server Settings
        settings_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Server Settings')]")
        settings_btn.click()
        time.sleep(1)

        server_info = {
            "name": server_name,
        }

        # Try to get additional info from settings page
        try:
            # Server icon
            icon_el = _browser.find_elements(By.CSS_SELECTOR, '[class*="serverIcon"]')
            if icon_el:
                server_info["has_icon"] = True

            # Member count (from overview)
            member_count = _browser.find_elements(By.XPATH, "//*[contains(text(), 'Members')]")
            if member_count:
                server_info["members_section_visible"] = True
        except:
            pass

        # Close settings
        try:
            _browser.find_element(By.CSS_SELECTOR, '[aria-label="Close"]').click()
        except:
            pass

        return {
            "success": True,
            "server": server_info
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to get server settings: {str(e)}"
        }


# ============================================================================
# Emoji & Sticker Tools
# ============================================================================

@mcp.tool()
def send_emoji(emoji_name: str) -> dict:
    """
    Send an emoji to the current channel.

    Args:
        emoji_name: Name of the emoji (e.g., "thumbsup", "heart", "smile").

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Find message input
        message_input = _browser.find_element(By.CSS_SELECTOR, 'div[role="textbox"]')
        message_input.click()

        # Type emoji shortcode
        message_input.send_keys(f":{emoji_name}:")
        time.sleep(0.5)

        # Send
        message_input.send_keys(Keys.ENTER)
        time.sleep(1)

        return {
            "success": True,
            "message": f"Sent emoji: :{emoji_name}:"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to send emoji: {str(e)}"
        }


@mcp.tool()
def open_emoji_picker() -> dict:
    """
    Open the emoji picker to view available emojis.

    Returns:
        Status dict with result.
    """
    global _browser

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    try:
        # Click emoji button next to message input
        emoji_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Select emoji"]')
        emoji_btn.click()
        time.sleep(1)

        return {
            "success": True,
            "message": "Emoji picker opened. Use send_emoji to send a specific emoji."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to open emoji picker: {str(e)}"
        }


@mcp.tool()
def send_sticker(sticker_name: str) -> dict:
    """
    Send a sticker to the current channel.

    Args:
        sticker_name: Name of the sticker to search for and send.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Click sticker button
        sticker_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="Open sticker picker"]')
        sticker_btn.click()
        time.sleep(1)

        # Search for sticker
        search_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="Search" i]')
        search_input.send_keys(sticker_name)
        time.sleep(0.5)

        # Click first matching sticker
        sticker_el = _browser.find_element(By.CSS_SELECTOR, '[class*="stickerAsset"]')
        sticker_el.click()
        time.sleep(1)

        return {
            "success": True,
            "message": f"Sent sticker: {sticker_name}"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": f"Sticker '{sticker_name}' not found."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to send sticker: {str(e)}"
        }


# ============================================================================
# Typing Indicator Tool
# ============================================================================

@mcp.tool()
def start_typing() -> dict:
    """
    Start showing typing indicator in the current channel.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Focus on message input - this typically shows typing
        message_input = _browser.find_element(By.CSS_SELECTOR, 'div[role="textbox"]')
        message_input.click()

        # Type and delete a character to trigger typing indicator
        message_input.send_keys(".")
        time.sleep(0.2)
        message_input.send_keys(Keys.BACKSPACE)

        return {
            "success": True,
            "message": "Typing indicator triggered. It will expire automatically."
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to start typing: {str(e)}"
        }


# ============================================================================
# DM Group Tools
# ============================================================================

@mcp.tool()
def create_group_dm(usernames: List[str]) -> dict:
    """
    Create a group DM with multiple users.

    Args:
        usernames: List of usernames to add to the group DM.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Navigate to DMs
        _browser.get("https://discord.com/channels/@me")
        time.sleep(2)

        # Click New Group DM button
        new_dm_btn = _browser.find_element(By.CSS_SELECTOR, '[aria-label="New Group DM"]')
        new_dm_btn.click()
        time.sleep(1)

        # Add each user
        for username in usernames:
            try:
                # Search for user
                search_input = _browser.find_element(By.CSS_SELECTOR, 'input[placeholder*="friend" i]')
                search_input.clear()
                search_input.send_keys(username)
                time.sleep(0.5)

                # Click on matching result
                result = _browser.find_element(
                    By.XPATH,
                    f"//div[contains(@class, 'friend') and .//span[contains(text(), '{username}')]]"
                )
                result.click()
                time.sleep(0.3)
            except:
                continue

        # Create the group DM
        create_btn = _browser.find_element(By.XPATH, "//button[contains(text(), 'Create')]")
        create_btn.click()
        time.sleep(2)

        return {
            "success": True,
            "message": f"Created group DM with: {', '.join(usernames)}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to create group DM: {str(e)}"
        }


# ============================================================================
# Search Tools
# ============================================================================

@mcp.tool()
def advanced_search(
    query: str = None,
    from_user: str = None,
    mentions_user: str = None,
    has: str = None,
    before: str = None,
    after: str = None,
    in_channel: str = None
) -> dict:
    """
    Perform an advanced search with filters.

    Args:
        query: Text to search for.
        from_user: Filter by message author.
        mentions_user: Filter by mentioned user.
        has: Filter by content type ("link", "embed", "file", "video", "image", "sound").
        before: Filter for messages before date (YYYY-MM-DD).
        after: Filter for messages after date (YYYY-MM-DD).
        in_channel: Filter by channel name.

    Returns:
        Dict with search results.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Build search query
        search_parts = []
        if query:
            search_parts.append(query)
        if from_user:
            search_parts.append(f"from: {from_user}")
        if mentions_user:
            search_parts.append(f"mentions: {mentions_user}")
        if has:
            search_parts.append(f"has: {has}")
        if before:
            search_parts.append(f"before: {before}")
        if after:
            search_parts.append(f"after: {after}")
        if in_channel:
            search_parts.append(f"in: {in_channel}")

        full_query = " ".join(search_parts)

        # Open search with Ctrl+F
        actions = ActionChains(_browser)
        actions.key_down(Keys.CONTROL).send_keys('f').key_up(Keys.CONTROL).perform()
        time.sleep(1)

        # Enter search query
        search_input = WebDriverWait(_browser, 10).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, 'input[placeholder*="Search"]'))
        )
        search_input.clear()
        search_input.send_keys(full_query)
        search_input.send_keys(Keys.ENTER)
        time.sleep(2)

        # Collect results
        results = []
        result_elements = _browser.find_elements(By.CSS_SELECTOR, '[class*="searchResult"]')

        for el in result_elements[:15]:
            try:
                text = el.text
                results.append({"content": text[:300] + "..." if len(text) > 300 else text})
            except:
                continue

        # Close search
        try:
            actions.send_keys(Keys.ESCAPE).perform()
        except:
            pass

        return {
            "success": True,
            "query": full_query,
            "results": results,
            "count": len(results)
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Search failed: {str(e)}"
        }


# ============================================================================
# Notification Settings Tools
# ============================================================================

@mcp.tool()
def mute_channel(duration: str = "forever") -> dict:
    """
    Mute the current channel.

    Args:
        duration: Mute duration - "15m", "1h", "8h", "24h", "forever". Default "forever".

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Right-click on channel header
        channel_header = _browser.find_element(By.CSS_SELECTOR, '[class*="title-"]')

        actions = ActionChains(_browser)
        actions.context_click(channel_header).perform()
        time.sleep(0.5)

        # Click Mute Channel
        mute_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Mute Channel')]")
        mute_btn.click()
        time.sleep(0.5)

        # Select duration
        duration_map = {
            "15m": "15 Minutes",
            "1h": "1 Hour",
            "8h": "8 Hours",
            "24h": "24 Hours",
            "forever": "Until I turn it back on"
        }
        duration_text = duration_map.get(duration, "Until I turn it back on")

        duration_btn = _browser.find_element(By.XPATH, f"//div[contains(text(), '{duration_text}')]")
        duration_btn.click()
        time.sleep(0.5)

        return {
            "success": True,
            "message": f"Channel muted for {duration}"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to mute channel: {str(e)}"
        }


@mcp.tool()
def unmute_channel() -> dict:
    """
    Unmute the current channel.

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Right-click on channel header
        channel_header = _browser.find_element(By.CSS_SELECTOR, '[class*="title-"]')

        actions = ActionChains(_browser)
        actions.context_click(channel_header).perform()
        time.sleep(0.5)

        # Click Unmute Channel
        unmute_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Unmute')]")
        unmute_btn.click()
        time.sleep(0.5)

        return {
            "success": True,
            "message": "Channel unmuted"
        }

    except NoSuchElementException:
        return {
            "success": False,
            "message": "Channel is not muted or unmute option not found."
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to unmute channel: {str(e)}"
        }


@mcp.tool()
def mute_server(duration: str = "forever") -> dict:
    """
    Mute the current server.

    Args:
        duration: Mute duration - "15m", "1h", "8h", "24h", "forever". Default "forever".

    Returns:
        Status dict with result.
    """
    global _browser, _discord_state

    if _browser is None:
        return {"success": False, "message": "Browser not running."}

    if not _discord_state["logged_in"]:
        return {"success": False, "message": "Not logged in to Discord."}

    try:
        # Click server name to open dropdown
        server_header = _browser.find_element(By.CSS_SELECTOR, '[class*="header-"] [class*="name-"]')
        server_header.click()
        time.sleep(0.5)

        # Click Notification Settings
        notif_btn = _browser.find_element(By.XPATH, "//div[@role='menu']//div[contains(text(), 'Notification')]")
        notif_btn.click()
        time.sleep(0.5)

        # Toggle Mute
        mute_toggle = _browser.find_element(By.XPATH, "//div[contains(text(), 'Mute')]//input[@type='checkbox']")
        if not mute_toggle.is_selected():
            mute_toggle.click()
        time.sleep(0.5)

        # Close
        _browser.find_element(By.CSS_SELECTOR, '[aria-label="Close"]').click()

        return {
            "success": True,
            "message": f"Server muted"
        }

    except Exception as e:
        return {
            "success": False,
            "message": f"Failed to mute server: {str(e)}"
        }


# Run the server
if __name__ == "__main__":
    mcp.run(transport="stdio")
